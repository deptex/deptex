/**
 * Single source of truth for loading project vulnerability graph data.
 * Used by ProjectVulnerabilitiesPage, TeamAlertsPage (team vulns), and OrganizationVulnerabilitiesPage.
 */

import { api, type ProjectVulnerability, type ProjectDependency } from './api';
import type { VulnGraphDepNode } from '../components/vulnerabilities-graph/useVulnerabilitiesGraphLayout';

function isVersionFixed(currentVersion: string, fixedVersions: string[]): boolean {
  if (!fixedVersions || fixedVersions.length === 0) return false;
  const cleanVersion = (v: string) => v.replace(/^[v^~>=<]+/, '').split('-')[0];
  const parseVersion = (v: string): number[] => {
    const cleaned = cleanVersion(v);
    return cleaned.split('.').map((p) => parseInt(p, 10) || 0);
  };
  const compareVersions = (a: string, b: string): number => {
    const partsA = parseVersion(a);
    const partsB = parseVersion(b);
    const maxLen = Math.max(partsA.length, partsB.length);
    for (let i = 0; i < maxLen; i++) {
      const numA = partsA[i] || 0;
      const numB = partsB[i] || 0;
      if (numA < numB) return -1;
      if (numA > numB) return 1;
    }
    return 0;
  };
  return fixedVersions.some(
    (fixedVersion) => compareVersions(currentVersion, fixedVersion) >= 0
  );
}

export interface ProjectVulnerabilityGraphResult {
  graphDepNodes: VulnGraphDepNode[];
}

/**
 * Load vulnerability graph data for a single project (vulns + deps + supply chains).
 * Returns the same graphDepNodes shape used by the project vulnerabilities tab.
 */
export async function loadProjectVulnerabilityGraphData(
  organizationId: string,
  projectId: string
): Promise<ProjectVulnerabilityGraphResult> {
  const activeVulns = (vulns: ProjectVulnerability[]) =>
    vulns.filter((v) => !isVersionFixed(v.dependency_version, v.fixed_versions ?? []));

  const [vulnData, deps] = await Promise.all([
    api.getProjectVulnerabilities(organizationId, projectId),
    api.getProjectDependencies(organizationId, projectId),
  ]);

  const active = activeVulns(vulnData);
  if (active.length === 0) {
    return { graphDepNodes: [] };
  }

  const vulnDepIds = new Set(active.map((v) => v.dependency_id));
  const vulnsByDepId = new Map<string, ProjectVulnerability[]>();
  active.forEach((v) => {
    const list = vulnsByDepId.get(v.dependency_id) ?? [];
    list.push(v);
    vulnsByDepId.set(v.dependency_id, list);
  });

  const directWithVulns = deps.filter(
    (d) => d.is_direct && d.dependency_id && vulnDepIds.has(d.dependency_id)
  );

  const toDepNode = (d: ProjectDependency): VulnGraphDepNode => ({
    id: d.id,
    name: d.name,
    version: d.version,
    is_direct: d.is_direct,
    parentId: 'project',
    license: d.license ?? null,
    vulnerabilities: (vulnsByDepId.get(d.dependency_id!) ?? []).map((v) => ({
      osv_id: v.osv_id,
      severity: v.severity,
      summary: v.summary,
      aliases: v.aliases ?? [],
      is_reachable: v.is_reachable,
      depscore: v.depscore ?? null,
      epss_score: v.epss_score ?? null,
      cvss_score: v.cvss_score ?? null,
      cisa_kev: v.cisa_kev ?? null,
      fixed_versions: v.fixed_versions ?? null,
    })),
    isZombie: d.is_direct && (d.files_importing_count ?? 0) === 0,
  });

  if (directWithVulns.length === 0) {
    const directNodes: VulnGraphDepNode[] = deps
      .filter((d) => d.dependency_id && vulnDepIds.has(d.dependency_id))
      .map(toDepNode);
    return { graphDepNodes: directNodes };
  }

  const directNodes: VulnGraphDepNode[] = directWithVulns.map(toDepNode);
  const allDirectDeps = deps.filter((d) => d.is_direct);
  const zombieDirectIds = new Set(
    allDirectDeps
      .filter((d) => d.is_direct && (d.files_importing_count ?? 0) === 0)
      .map((d) => d.id)
  );
  const directDepNameVersion = new Set(directNodes.map((n) => `${n.name}\t${n.version}`));
  const vulnNameVersionSet = new Set(
    active.map((v) => `${v.dependency_name}\t${v.dependency_version}`)
  );

  const batchResult = await api.getBatchSupplyChains(
    organizationId,
    projectId,
    allDirectDeps.map((d) => d.id)
  );

  const chains = allDirectDeps.map((dep) => ({
    children: batchResult[dep.id]?.children ?? [],
  }));

  const seenTransitive = new Set<string>();
  const transitiveNodes: VulnGraphDepNode[] = [];
  const parentBridgeNodes: VulnGraphDepNode[] = [];
  const addedParentIds = new Set<string>();

  chains.forEach((chain, idx) => {
    const directDep = allDirectDeps[idx];
    const directHasVulns = vulnDepIds.has(directDep.dependency_id!);
    if (!chain?.children) return;

    chain.children.forEach((child) => {
      if (child.vulnerabilities.length === 0) return;
      const key = `${child.name}\t${child.version}`;
      if (!vulnNameVersionSet.has(key)) return;
      if (directDepNameVersion.has(key)) return;
      if (seenTransitive.has(child.dependency_version_id)) return;
      seenTransitive.add(child.dependency_version_id);

      if (!directHasVulns && !addedParentIds.has(directDep.id)) {
        addedParentIds.add(directDep.id);
        parentBridgeNodes.push({
          id: directDep.id,
          name: directDep.name,
          version: directDep.version,
          is_direct: true,
          parentId: 'project',
          license: directDep.license ?? null,
          vulnerabilities: [],
          isZombie:
            directDep.is_direct && (directDep.files_importing_count ?? 0) === 0,
        });
      }

      const transitiveIsZombie = zombieDirectIds.has(directDep.id);
      transitiveNodes.push({
        id: child.dependency_version_id,
        name: child.name,
        version: child.version,
        is_direct: false,
        parentId: directDep.id,
        license: child.license ?? null,
        vulnerabilities: (child.vulnerabilities ?? []).map((v) => ({
          osv_id: v.osv_id,
          severity: v.severity,
          summary: v.summary ?? null,
          aliases: v.aliases ?? [],
          is_reachable: v.is_reachable,
        })),
        isZombie: transitiveIsZombie,
      });
    });
  });

  const graphDepNodes: VulnGraphDepNode[] = [
    ...directNodes,
    ...parentBridgeNodes,
    ...transitiveNodes,
  ];

  return { graphDepNodes };
}
